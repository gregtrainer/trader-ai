#Import all dependencies
import pandas as pd # import pandas as required
pd.set_option("display.max_rows", None, "display.max_columns", None)  # set display options for pandas

# Date/time
from datetime import date, time, datetime, timedelta
import time

import numpy as np  # Numpy

import os.path as path

# Initial setups
date_today = date.today()
date_time_now = datetime.now()

# data file paths set
resource_path = "resources/"
data_file_portfolio = "portfolio.csv"
data_file_ledger = "ledger.csv"
data_portfolio_path = resource_path + data_file_portfolio
data_ledger_path = resource_path + data_file_ledger


def setup_frames():
# setup pandas dataframe of ledger and portfolio for testing

    date_today = date.today()
    date_time_now = datetime.now()

    # specify dataframes as global variables, so that all functions can use them

    global ledger_df
    global portfolio_df

    # If the CSV files exist:
    if path.exists(data_portfolio_path):
        # convert the csv into the frame
        print("Converting CSV: ", data_portfolio_path, " to DF")
        portfolio_df = convert_CSV_pandas(data_portfolio_path)
    else:
        # create the portfolio frame
        print("Creating: ", data_portfolio_path)
        portfolio_df = pd.DataFrame(columns=['Coin', 'Coin Price', 'Volume', 'Transaction Cost', 'Transaction Cost-Fees(inc)' ])
        convert_pandas_CSV(data_portfolio_path, portfolio_df)

    # If the CSV files exist:
    if path.exists(data_ledger_path):
        # convert the csv into the frame
        print("Converting CSV: ", data_ledger_path, " to DF")
        ledger_df = convert_CSV_pandas(data_ledger_path)
    else:
        # create the ledger frame
        print("Creating: ", data_ledger_path)
        starting_balance = 120.00
        ledger_df = pd.DataFrame(columns=['Date', 'Method', 'Coin', 'Coin Price', 'Volume', 'Available Balance', 'Buy Cost', 'Sell Cost', 'Running Balance', 'Profit', 'Running Profit'])
        ledger_df.loc[ledger_df.shape[0]] = [date_time_now, 'Initial', 'BLANK', 0, 0, starting_balance, 0, 0, starting_balance, 0, 0]
        convert_pandas_CSV(data_ledger_path, ledger_df)


    #return ledger_df, portfolio_df

def convert_pandas_CSV(file, data):
    data.to_csv(file, encoding='utf-8', index=False)

def convert_CSV_pandas(file):
    panda_data = pd.read_csv(file)
    return panda_data




def get_IR_connection():
    # establish the connection to IR and store public/private connections as global
    import independentreserve as ir

    # API keys from IR
    api_key = "eb6b8562-6242-4454-abcb-1c0c6273db23"
    api_secret = "ea33af197f734af5a0e42c62bd78cf8a"

    global ir_public
    ir_public = ir.PublicMethods()

    global ir_private
    ir_private = ir.PrivateMethods(api_key, api_secret)


def get_IR_available():
    # obtain the available balance from the IR account, return the amount.
    print("Obtaining - IR available balance")
    ir_account = ir_private.get_accounts()
    ir_account_aud = list(filter(lambda ir_account: ir_account['CurrencyCode'] == 'Aud', ir_account))
    ir_account_available = ir_account_aud[0]['AvailableBalance']
    print("IR_Account_Available Balance: ", ir_account_available)

    return ir_account_available

def get_DF_avaialble(ledger_df):
    # deritmine available amount made based on ledger
    ir_account_available = ledger_df['Running Balance'].iloc[-1]
    print("Amount available from DF is: ", ir_account_available)
    return ir_account_available

def get_DF_profit_made(ledger_df):
    # deritmine profit made based on ledger
    ir_profit_made = ledger_df['Running Profit'].iloc[-1]
    print("Profit made is: ",ir_profit_made)
    return ir_profit_made

def get_ir_coins_available():
    # IR get the available coins to buy
    ir_coin_list = ir_public.get_valid_primary_currency_codes()
    print("Coin list obtained from IR is: ", ir_coin_list)
    return ir_coin_list


def detirmine_ok_buy(ir_minimum_deposit, ir_available_to_spend):
    # check if available amount is equal to or more than then minimum amount
    if ir_minimum_deposit <= ir_available_to_spend:
        print("The amount available is MORE than the IR minimum purchase")
        print("-BUY - True")
        return True
    else:
        print("The amount available is LESS than the IR minimum purchase")
        print("-BUY - False")
        return False


# IR market summary - offers current market summary for specified coin.
def get_coin_market_price(method, coin):
    ir_market = ir_public.get_market_summary(coin, currency)
    market_timestamp = ir_market['CreatedTimestampUtc']
    buy_coin_price = ir_market['CurrentLowestOfferPrice']  # buying market price
    sell_coin_price = ir_market['CurrentHighestBidPrice']  # buying market price
    # print("Coin IR BUY market data: ", buy_coin_price)
    # print("Coin IR SELL market data: ", sell_coin_price)
    if method == 'Buy':
        return market_timestamp, buy_coin_price
    if method == 'Sell':
        return market_timestamp, sell_coin_price


def place_market_order(coin, volume, currency, cost):
    # place market order test
    print("The market order info: ")
    print("Coin is: ", coin)
    print("Volume is: ", volume)
    print("Currency is ", currency)
    print("Fixed price of coin is: ", cost)
    # experiment with 'VolumeCurrencyType'=Secondary to place order based on currency  not volume.
    # market_order = ir_private.place_market_order(volume, coin, currency, order_type="LimitBid")
    # print(market_order)

    # Simulating market order ok
    # market_order =


def place_limit_bid(coin, coin_cost, volume):
    print("The limit order info: ")
    print("Coin is: ", coin)
    print("Volume is: ", volume)
    print("Currency is ", currency)
    print("Fixed price of coin is: ", coin_cost)
    # limit_order = ir_private.place_limit_order(coin_cost, volume, currency, order_type="LimitBid")

    # get transaction date
    date_time_now = datetime.now()

    # assumed transaction cost
    transaction_cost = (coin_cost * volume)
    transaction_cost_with_fees = transaction_cost + (transaction_cost * ir_transaction_fee_percentage) + (transaction_cost * ir_gst_percentage)

    # if limit order is successful, add details to portfolio and ledger
    # add to ledger function - pass date, method, coin, bid price, volume bid, transaction cost, ledger
    add_to_ledger(date_time_now, 'Buy', coin, coin_cost, volume, transaction_cost,transaction_cost_with_fees,0)

    # add coin to portfolio df
    add_to_portfolio(coin, coin_cost, volume, transaction_cost, transaction_cost_with_fees)

def add_to_ledger(date, method, coin, coin_cost, volume, transaction_cost,transaction_cost_with_fees, sell_profit):

    #data format for ledger: date, transaction_type, coin, coin_cost, volume, df_previous_balance, transaction_cost, sell_cost, running_balance, profit_made, running_profit
    # Date,Method,Coin,Coin Price,Volume,Available Balance,Buy Cost,Sell Cost,Running Balance,Profit,Running Profit
    # obtain relevant details
    df_previous_balance = get_DF_avaialble(ledger_df)
    df_previous_profit = get_DF_profit_made(ledger_df)

    if method == 'Buy':
        transaction_type = 'BUY-Limit'
        running_balance = df_previous_balance - transaction_cost_with_fees
        profit_made = 0
        running_profit = df_previous_profit
        sell_cost = 0

    if method == 'Sell':
        transaction_type = 'SELL-Limit'
        running_balance = df_previous_balance + transaction_cost_with_fees
        profit_made = sell_profit
        running_profit = df_previous_profit + sell_profit
        sell_cost = transaction_cost_with_fees



    #Ledger format- Date', 'Method', 'Coin', 'Coin Price', 'Volume', 'Available Balance', 'Buy Cost', 'Sell Cost', 'Running Balance', 'Profit', 'Running Profit'])
    ledger_df.loc[ledger_df.shape[0]] = [date, transaction_type, coin, coin_cost, volume, df_previous_balance, transaction_cost_with_fees, sell_cost, running_balance, profit_made, running_profit]
    print(ledger_df)

    convert_pandas_CSV(data_ledger_path, ledger_df)

def add_to_portfolio(coin, price, volume, transaction_cost, transaction_cost_with_fees):

    # Portfolio format coin, price, volume, transaction_cost
    portfolio_df.loc[portfolio_df.shape[0]] = [coin, price, volume, transaction_cost, transaction_cost_with_fees]
    print(portfolio_df)

    convert_pandas_CSV(data_portfolio_path, portfolio_df)

def place_limit_offer(sell_index, sell_coin, coin_price, sell_coin_volume, sell_transaction, sell_transaction_minus_profit, sell_profit):

    print("The limit order info: ")
    print("Sell index is: ", sell_index)
    print("Coin is: ", sell_coin)
    print("Volume is: ", sell_coin_volume)
    print("Currency is ", currency)
    print("Fixed price of coin is: ", coin_price)
    print("The assumed transaction amount for this is: ", sell_transaction)
    print("The assumed transaction minus profit percentage amount for this is: ", sell_transaction_minus_profit)

    # calculate profit
    print("The profit from this transaction is: ", sell_profit)

    # The running profit calculation
    running_profit = ledger_df['Running Profit'].iloc[-1] + sell_profit
    print("Running profit after this transaction is: ", running_profit)

    # limit_order = ir_private.place_limit_order(coin_cost, volume, currency, order_type="LimitBid")

    # get transaction date
    date_time_now = datetime.now()

    # assumed transaction cost
    transaction_cost = (coin_price * sell_coin_volume)
    transaction_cost_plus_fees = transaction_cost - (transaction_cost * ir_transaction_fee_percentage) - (transaction_cost * ir_gst_percentage)

    # if limit order is successful, add details to portfolio and ledger
    #add_to_ledger(date, method, coin, coin_cost, volume, transaction_cost,transaction_cost_with_fees):
    add_to_ledger(date_time_now, 'Sell', sell_coin, coin_price, sell_coin_volume, transaction_cost, transaction_cost_plus_fees, sell_profit)
    # Ledger format- Date', 'Method', 'Coin', 'Coin Price', 'Volume', 'Available Balance', 'Buy Cost', 'Sell Cost', 'Running Balance', 'Profit', 'Running Profit'])
    #ledger_df.loc[ledger_df.shape[0]] = [date_time_now, 'SELL-Limit', sell_coin, coin_price, sell_coin_volume, 0, sell_coin_volume, sell_profit, running_profit]
    #convert_pandas_CSV(data_ledger_path, ledger_df)

    # remove coin from portfolio df and update CSV
    portfolio_df.drop([sell_index], axis=0, inplace=True)
    convert_pandas_CSV(data_portfolio_path, portfolio_df)

    # testing - update ir_available_amount to reflect transaction cost
    #global ir_account_available
    #ir_account_available = ir_account_available + sell_transaction
    #print("Updated IR Account availability is: ", ir_account_available)


def get_closed_orders():
    ir_closed_orders = ir_private.get_closed_orders()
    print(ir_closed_orders)




def get_ir_trade_history(coin, currency, hours_history):
    # Gather history in last x days for coins in available list
    ir_trade_coin_history = ir_public.get_trade_history_summary(coin, currency, hours_history)['HistorySummaryItems']
    # print(ir_trade_coin_history)

    # format the trade history dictionary into meanningful data (timestamp, closing price
    # make the dataframe
    ir_trade_history = pd.DataFrame(ir_trade_coin_history)

    # Set index to the start timeframe
    ir_trade_history.set_index(ir_trade_history['StartTimestampUtc'], inplace=True, drop=True)
    ir_trade_history.index.names = ['Timestamp']

    # drop all columns apart from the Closing currency price and rename
    ir_trade_history = ir_trade_history[['ClosingSecondaryCurrencyPrice']]
    ir_trade_history.rename(columns={'ClosingSecondaryCurrencyPrice': 'Close'}, inplace=True)

    print("IR trade history for coin: ", coin)
    #print(ir_trade_history)
    return ir_trade_history


def get_ir_live_data(method, coin, interval, cycles):
    current_cycles = 0
    live_frame = pd.DataFrame()

    while current_cycles < cycles:
        live_time, live_price = get_coin_market_price(method, coin)
        temp_df = {'Timestamp': live_time, 'Close': live_price}
        # live_df = create_live_data_frame(live_price)
        # add frame to existing
        live_frame = live_frame.append(temp_df, ignore_index=True)

        current_cycles = current_cycles + 1
        time.sleep(interval)

    print("IR live data for coin: ", coin)
    #print(live_frame)
    return live_frame


def sort_buy_list(list):
    # sort the buy list by element 1 which is the slope
    def takeSecond(elem):
        return elem[1]

    list.sort(reverse=True, key=takeSecond)

    print("Buy list sorted is: ", list)
    return list

# Trend - SMA
def trend_SMA(history_data, sma_1, sma_2, sma_3):
    # copy the history data so it can be manipulated
    data = history_data.copy()

    # calculate 1st moving average using Pandas
    data[sma_1, 'sma'] = data['Close'].rolling(sma_1).mean()
    # calculate 2nd moving average using Pandas
    data[sma_2, 'sma'] = data['Close'].rolling(sma_2).mean()
    # calculate 3rd moving average using Pandas
    data[sma_3, 'sma'] = data['Close'].rolling(sma_3).mean()

    # Calculate signal column
    data['Signal'] = np.where(data[sma_1, 'sma'] > data[sma_2, 'sma'], 1, 0)  # NaN is not a number

    # Calculate position column with diff
    data['trend_sma'] = data['Signal'].diff()
    data['Buy'] = np.where(data['trend_sma'] == 1, data['Close'], np.NaN)
    data['Sell'] = np.where(data['trend_sma'] == -1, data['Close'], np.NaN)

    history_data['trend_sma'] = data['trend_sma']

    return history_data


# Trend - trend line coef analysis
def trend_coef(history_data, rollwindow):
    # copy the history data so it can be mannipulated if needed
    data = history_data.copy()

    data['trend_coef'] = np.sign(data['Close'].rolling(window=rollwindow).mean().diff().fillna(0)).map(
        {0: 0.0, 1: 1.0, -1: -1.0})

    history_data['trend_coef'] = data['trend_coef']

    return history_data


# Trend - detirmine slope based on hour duration.

def trend_slope(history_data, hour_interval):
    data = history_data.copy()

    price_end = data.iloc[-1]['Close']
    price_start = data.iloc[-hour_interval]['Close']
    data['trend_slope'] = (price_end - price_start) / hour_interval

    history_data['trend_slope'] = data['trend_slope']

    return history_data


def apply_buy_trends_and_list(buy_coin, coin_history):
    # apply trends required
    coin_history_trend = trend_SMA(coin_history, 3, 4, 5)  # apply SMA
    coin_history_trend = trend_coef(coin_history, 3)  # apply trend coef
    coin_history_trend = trend_slope(coin_history, 2)  # apply slope

    trend_of_last_record_coef = coin_history_trend.iloc[-1]['trend_coef']
    trend_of_last_record_sma = coin_history_trend.iloc[-1]['trend_sma']
    trend_of_last_record_slope = coin_history_trend.iloc[-1]['trend_slope']

    #print(buy_coin)
    print(coin_history_trend.tail(5))
    #print("The SMA trend of the last record of ", buy_coin, " is ", trend_of_last_record_sma)
    #print("The COEF trend of the last record of ", buy_coin, " is ", trend_of_last_record_coef)
    #print("The SLOPE trend of the last record of ", buy_coin, " is ", trend_of_last_record_slope)

    # if this is checking for a buy condition
    # buy conditions
    buy_required_slope = 0.05

    #if trend_of_last_record_coef == 1.0 and trend_of_last_record_slope >= buy_required_slope:
    if trend_of_last_record_slope >= buy_required_slope:
        print("Coin: ", buy_coin, " meets buying params - adding to list")

        # detirmine the cost of the coin to buy (current market data)
        coin_timestamp, coin_price = get_coin_market_price("Buy", buy_coin)

        # add the coin to the to_buy_list
        to_buy_list.append([buy_coin, trend_of_last_record_slope, coin_price])
    else:
        print("Coin: ", buy_coin, " DOES NOT meet buying params")

    return to_buy_list


def apply_sell_trends_and_execute(coin_history, sell_index, sell_coin, sell_coin_cost_price, sell_coin_volume, sell_coin_cost_transaction_total):

    # apply trends required
    coin_history_trend = trend_SMA(coin_history, 3, 4, 5)  # apply SMA
    coin_history_trend = trend_coef(coin_history, 5)  # apply trend coef
    coin_history_trend = trend_slope(coin_history, 3)  # apply slope

    trend_of_last_record_coef = coin_history_trend.iloc[-1]['trend_coef']
    trend_of_last_record_sma = coin_history_trend.iloc[-1]['trend_sma']
    trend_of_last_record_slope = coin_history_trend.iloc[-1]['trend_slope']

    #print(sell_coin)
    #print(coin_history_trend.tail(5))
    #print("The SMA trend of the last record of ", sell_coin, " is ", trend_of_last_record_sma)
    #print("The COEF trend of the last record of ", sell_coin, " is ", trend_of_last_record_coef)
    #print("The SLOPE trend of the last record of ", sell_coin, " is ", trend_of_last_record_slope)

    # if this is checking for a sell condition
    sell_required_slope = 0.00

    # if trend_of_last_record_coef == -1.0 and trend_of_last_record_slope < sell_required_slope:
    if trend_of_last_record_slope <= sell_required_slope:
        print("Coin: ", sell_coin, " meets trend SELLING params")

        # detirmine the cost of the coin to sell (current market data)
        coin_timestamp, coin_price = get_coin_market_price("Sell", sell_coin)

        # detirmine the transaction cost of this sell - if all volume was sold at current limit price
        sell_transaction = coin_price * sell_coin_volume
        print("SELL - Coin ", sell_coin, " volume ", sell_coin_volume, " for price ", coin_price, ' equals = ',sell_transaction)
        sell_transaction_minus_fees = sell_transaction - (sell_transaction * ir_transaction_fee_percentage) - (sell_transaction * ir_gst_percentage)
        print("SELL - Coin ", sell_coin, " after ALL fees taken away: ", sell_transaction_minus_fees)

        # detimrine if sell transaction meets profit over inital transaction cost
        sell_transaction_minus_profit = sell_transaction_minus_fees - (sell_transaction_minus_fees * ir_profit_required_percentage)
        print("SELL - Coin ", sell_coin, " with profit margin applied: ", sell_transaction_minus_profit)
        print("Initial transaction price for this coin sell was: ", sell_coin_cost_transaction_total)

        sell_profit = sell_transaction_minus_profit - sell_coin_cost_transaction_total

        if sell_profit >= 0:
            print("Coin: ", sell_coin, " meets profit SELLING params - LETS SELL IT")

            place_limit_offer(sell_index, sell_coin, coin_price, sell_coin_volume, sell_transaction, sell_transaction_minus_profit, sell_profit)


        else:
            print("Coin: ", sell_coin, " DOES NOT profit SELLING params")

    else:
        print("Coin: ", sell_coin, " DOES NOT trend SELLING params")


############################# INITILISATION ################################

# Establish the portfolio and ledger data frames
#ledger_df, portfolio_df = setup_frames()
setup_frames()

# Establish the IR connection details
get_IR_connection()

# detirmine amount available from ledger
ir_amount_available = get_DF_avaialble(ledger_df)

# detirmine profit made from ledger
ir_profit_made = get_DF_profit_made(ledger_df)

# specify IR transaction costs
ir_transaction_fee_percentage = 0.005  # 0.5% of transaction cost
ir_gst_percentage = 0.10
ir_minimum_deposit = 100.00  # minimum of $100 AUD / coint for deposits and withrdwals based on no fees if above this.
ir_maximum_cost = 300.00  # maximum amount of purchase per coin
ir_max_num_coins_to_buy = 5
ir_trade_history_hours = 24  # Amount of hours in history to get trade data
ir_profit_required_percentage = 0.00  # Amount of profit required to initiate sell

currency = 'Aud'  # currency to always refer and trade in

############################# START OF TRADE OPS ################################
date_time_now = datetime.now()
print("The trade operation is running at time/date: ", date_time_now)

############################ BUY intitialisation #####################################
# detirmine if amount available to spend meets requirements.
ir_amount_to_spend = ir_amount_available - ir_profit_made  # detimrine the amount of money in account that is NOT profit.
ir_available_to_spend = ir_amount_to_spend - (ir_amount_to_spend * ir_transaction_fee_percentage) - (ir_amount_to_spend * ir_gst_percentage)
print("The amount to spend has been set to (AFTER fees and profit): ", ir_available_to_spend)

if detirmine_ok_buy(ir_minimum_deposit, ir_available_to_spend):
    print("BUY CYCLE START")

    # get available coins to purchase
    ir_coin_list = get_ir_coins_available()

    # intitialise the buy list
    to_buy_list = []

    # Loop through each coin on available list
    for buy_coin in ir_coin_list:

        # get historical data for coin to detirmine trend
        coin_history = get_ir_trade_history(buy_coin, currency, ir_trade_history_hours)

        # get real time data for coin to detimrine trend, interval, cycles
        #coin_history = get_ir_live_data('Buy',buy_coin,2, 5)


        if not coin_history.empty:
            # obtain buy list with coin, current market buy price and slope 'to order'.
            to_buy_list = apply_buy_trends_and_list(buy_coin, coin_history)

    # if there are coins to buy on the list
    if len(to_buy_list) > 0:

        to_buy_list = sort_buy_list(to_buy_list)

        # strip the buy list down to maximum number of coins
        to_buy_list_stripped = to_buy_list[0:ir_max_num_coins_to_buy]
        length_of_buy_list = len(to_buy_list_stripped)
        print("Buy list reduced to max num of coins is: ",to_buy_list_stripped)
        print("Buy list length is: ", length_of_buy_list)


        # detimrine amount of curreny available per coin purchase
        amount_available_per_coin = ir_available_to_spend / length_of_buy_list
        print("The amount available to purchase per coin is: ", amount_available_per_coin)

        # loop through each item on to buy list stripped and sorted
        for coin, coin_slope, coin_cost in to_buy_list_stripped:
            # detirmine volume amount to purchase for coin
            volume_to_buy = amount_available_per_coin / coin_cost

            # place_market_order(coin, volume_to_buy, currency, cost)
            # Place a limit bid on the coin for that amount of volume
            # maybe a buy coin function instead to change buy method easier ?

            # buy coin function (coin, coin_cost, volume_to_buy)
            place_limit_bid(coin, coin_cost, volume_to_buy)



# SELLING cycle if ok -based on if there is anhthing in the portfolio
if not portfolio_df.empty:
    print("Portfolio not empty - starting selling cycle")
    # Loop through each coin within the portfolio
    # iterate over rows with iterrows()
    for index, row in portfolio_df.head().iterrows():
        # access data using column names
        print(index, row['Coin'], row['Coin Price'], row['Volume'], row['Transaction Cost'], row['Transaction Cost-Fees(inc)'])
        sell_index = index
        sell_coin = row['Coin']
        sell_coin_cost_price = row['Coin Price']
        sell_coin_volume = row['Volume']
        sell_coin_cost_transaction_price = row['Transaction Cost']
        sell_coin_cost_transaction_total = row['Transaction Cost-Fees(inc)']

        # apply trend to coin based on history data
        # coin_history = get_ir_trade_history(sell_coin, currency, ir_trade_history_hours)

        # get real time data for coin to detimrine trend, internval, cycles
        coin_history = get_ir_live_data('Sell', sell_coin, 2, 5)

        # if the coin history was successful
        if not coin_history.empty:
            print("Apply trends to SELL coin history")
            # apply buy trends and generate buy list
            apply_sell_trends_and_execute(coin_history, sell_index, sell_coin, sell_coin_cost_price, sell_coin_volume, sell_coin_cost_transaction_total)
